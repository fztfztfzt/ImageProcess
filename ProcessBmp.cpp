#include <windows.h>
#include "ProcessBmp.h"

#include <cmath>
typedef struct tagBITMAPFILEHEADER
{
	WORD bfType;//位图文件的类型，必须为BM(1-2字节）
	DWORD bfSize;//位图文件的大小，以字节为单位（3-6字节，低位在前）
	WORD bfReserved1;//位图文件保留字，必须为0(7-8字节）
	WORD bfReserved2;//位图文件保留字，必须为0(9-10字节）
	DWORD bfOffBits;//位图数据的起始位置，以相对于位图（11-14字节，低位在前）
					//文件头的偏移量表示，以字节为单位
}BITMAPFILEHEADER;
typedef struct tagBITMAPINFOHEADER {
	DWORD biSize;//本结构所占用字节数（15-18字节）
	LONG biWidth;//位图的宽度，以像素为单位（19-22字节）
	LONG biHeight;//位图的高度，以像素为单位（23-26字节）
	WORD biPlanes;//目标设备的级别，必须为1(27-28字节）
	WORD biBitCount;//每个像素所需的位数，必须是1（双色），（29-30字节）
					//4(16色），8(256色）16(高彩色)或24（真彩色）之一
	DWORD biCompression;//位图压缩类型，必须是0（不压缩），（31-34字节）
						//1(BI_RLE8压缩类型）或2(BI_RLE4压缩类型）之一
	DWORD biSizeImage;//位图的大小(其中包含了为了补齐行数是4的倍数而添加的空字节)，以字节为单位（35-38字节）
	LONG biXPelsPerMeter;//位图水平分辨率，每米像素数（39-42字节）
	LONG biYPelsPerMeter;//位图垂直分辨率，每米像素数（43-46字节)
	DWORD biClrUsed;//位图实际使用的颜色表中的颜色数（47-50字节）
	DWORD biClrImportant;//位图显示过程中重要的颜色数（51-54字节）
}BITMAPINFOHEADER;
typedef struct tagRGBQUAD{
	BYTE rgbBlue;//蓝色的亮度（值范围为0-255)
	BYTE rgbGreen;//绿色的亮度（值范围为0-255)
	BYTE rgbRed;//红色的亮度（值范围为0-255)
	BYTE rgbReserved;//保留，必须为0
}RGBQUAD;
void ProcessBmp::LoadBmp(unsigned char * filepath,BYTE *bmp,long &width,long &height)
{
	FILE *file = fopen(filepath, "rb");
	assert(file != NULL);
	//读取bmp头
	fread(&bmpFileHead, sizeof(BITMAPFILEHEADER), 1, file);
	assert(bmpFileHead.bfType == 0x4d42);
	DWORD sumNum = bmpFileHead.bfSize;//这个长度是数据长度
	DWORD offNum = bmpFileHead.bfOffBits;//数据偏移头部长度
	fread(&bmpInfoHead, sizeof(BITMAPINFOHEADER), 1, file);
	assert(bmpInfoHead.biCompression == 0);
	biBitCount = bmpInfoHead.biBitCount;
	long nPlantNum;
	if (bmpInfoHead.biBitCount < 24)//读取调色板
	{
		nPlantNum = long(pow(2, double(bmpInfoHead.biBitCount)));    //   Mix color Plant Number;
		pPal = new tagRGBQUAD[nPlantNum*sizeof(tagRGBQUAD)];
		memset(pPal, 0, nPlantNum*sizeof(tagRGBQUAD));
		fread(pPal, 4, nPlantNum, file);
	}
	else pPal = NULL;
	bmpWidth = width = bmpInfoHead.biWidth;//宽度必须是4B的倍数
	height = bmpInfoHead.biHeight;
	if (bmpInfoHead.biBitCount < 24)//注意宽度的计算方式
	{
		width = (width % (32 / biBitCount) == 0) ? width : (width / (32 / biBitCount) + 1) * (32 / biBitCount);//宽度调整为4B 32的倍数
																											   // width = (width+3)/4*4;
		width = width*biBitCount / 8;
	}
	else
		width = (width*biBitCount / 8 + 3) / 4 * 4;
	height = abs(height);
	bmp = new unsigned char[height*width];
	fread(bmp, 1, height*width, file);
	fclose(file);
}
void ProcessBmp::ShowBmp(int x, int y, unsigned char * bmp, long width, long height)
{
	HDC dc = GetWindowDC(GetDesktopWindow());
	for (int j = 0; j < height; j++)
		for (int i = 0; i < width; i++)//宽度变长，比如2倍，图像会显示2副，第二幅为第一副的隔行
		{
			b = bmp[j*width*3 + i*3];
			g = bmp[j*width*3 + i*3 + 1];
			r = bmp[j*width*3 + i*3 + 2];
			SetPixel(dc,x + i, y + height - j, RGB(r, g, b));
		}
}